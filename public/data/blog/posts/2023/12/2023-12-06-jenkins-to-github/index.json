{
  "id": "2023-12-2023-12-06-jenkins-to-github",
  "url": "/blog/2023/12/01/2023-12-06-jenkins-to-github/",
  "title": "Log from Jenkins Jobs to GitHub Pull Requests as Checks",
  "date": "2023-12-01",
  "authors": [
    "tslmy"
  ],
  "tags": [
    "jenkins",
    "github"
  ],
  "summary": "An overview about methods by which you can log stuff from a Jenkins job to a GitHub PR as “Checks”.",
  "opengraph_image": "/images/post-images/2023/12/06/jenkins-to-github-checks.png",
  "content_html": "<div class=\"paragraph\">\n<p>You have a <strong>GitHub repo</strong> and a <strong>Jenkins server</strong>.\nThe Jenkins server has jobs for running unit tests, computing code coverages, and executing static analyses.</p>\n</div>\n<div class=\"paragraph\">\n<p>Every time someone opens a PR to your repo, you ask them to run those jobs, take screenshots of the results, and paste these screenshots to the PR description as a <strong>proof of quality</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>That's too much waiting and too many keystrokes.\n<strong>People want automation</strong>: when they create a PR (or push a commit), those jobs should start to build.\nWhen the builds are done, the results should be conveniently visible at the \"Checks\" section at the bottom of the PR, like this:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"/images/post-images/2023/12/06/Screenshot-of-a-typical-PR-Checks-list.png\" alt=\"Screenshot of a typical PR Checks list\"></span></p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"ways-to-publish-checks-to-prs-statuses-checks-and-actions\"><a class=\"anchor\" href=\"#ways-to-publish-checks-to-prs-statuses-checks-and-actions\"></a>Ways to publish checks to PRs: Statuses, Checks, and Actions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You thought about your options.\nThere are 3 types of entries that can be shown in this little box.\nIn order of increasing complexity to configure:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>Statuses</strong>, or as I'd like to call them, <strong>Commit Checks</strong>.\nThey are associated with commits, not PRs.\nThis means you can run them even without creating a PR.\nFor example, here are some Commit Checks on a commit I directly pushed to a <code>master</code> branch:\n<span class=\"image\"><img src=\"/images/post-images/2023/12/06/Screenshot-of-a-list-of-commit-statuses.png\" alt=\"Screenshot of a list of commit statuses\"></span></p>\n</li>\n<li>\n<p><strong>Checks</strong>, or more explicitly, <strong>PR Checks</strong>.\nThese are run on commits but are stored with the PRs.\nWith them, you can write long essays of messages to the \"Checks\" tab of a PR, but they do require authenticating as a GitHub App instead of a user, so it's more complicated to set up.\nSonarCloud, a code analyzer, makes use of PR Checks via <a href=\"https://github.com/apps/sonarcloud\">their namesake GitHub App</a>.\nIf you look closer, their report is just Markdown:\n<span class=\"image\"><img src=\"/images/post-images/2023/12/06/Screenshot-of-a-SonarCloud-Code-Analysis-as-a-GitHub-PR-Check.png\" alt=\"Screenshot of a SonarCloud Code Analysis as a GitHub PR Check\"></span></p>\n</li>\n<li>\n<p><strong>GitHub Actions</strong> (GA).\nGA is a different kind of CI system from Jenkins.\nSince this article is about Jenkins only, GA is only mentioned here for the sake of completeness.\n<span class=\"image\"><img src=\"/images/post-images/2023/12/06/Screenshot-of-a-GitHub-Action-as-a-PR-Check.png\" alt=\"Screenshot of a GitHub Action as a PR Check\"></span></p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"when-the-result-is-simple-use-commit-statuses\"><a class=\"anchor\" href=\"#when-the-result-is-simple-use-commit-statuses\"></a>When the result is simple: Use commit statuses</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Jenkins jobs you want to trigger only run for a couple of seconds.\nEach only emits a simple result: pass or fail.\nYou don't need fancy reports, so <strong>commit statuses</strong> seem to be a suitable choice.</p>\n</div>\n<div class=\"paragraph\">\n<p>You installed <a href=\"https://plugins.jenkins.io/github/\">the GitHub plugin</a> to your Jenkins server and followed <a href=\"https://stackoverflow.com/a/51003334/1147061\">this guide</a> to set it up.\nYou are now able to emit simple one-liners as checks like this:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"https://raw.githubusercontent.com/jenkinsci/github-coverage-reporter/readme/assets/coverage-success.png\" alt=\"coverage success\"></span>\n<em>(<a href=\"https://github.com/jenkinsci/github-coverage-reporter-plugin\">source</a> of screenshot; Apache 2.0 licensed)</em></p>\n</div>\n<div class=\"paragraph\">\n<p>It met your immediate need, but it stills falls short in a number of ways:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The plugin publishes to the PR only thrice: upon getting queued, upon the start, and upon completion.\nYour job actually has <strong>many</strong> time-consuming stages, such as building a manifest, deploying to staging, and running tests.\nThese stages are often packed in a single script and you <strong>want to be notified at each stage</strong>.</p>\n</li>\n<li>\n<p>The messages show up with <strong>your GitHub profile image as the icon</strong>, because Jenkins is using <em>your</em> PAT!\nYou want to shy away from the spotlight, maybe because you don't want to be mistaken by your less-GitHub-savvy collaborators as a ruthless robot critiquing (and blocking) everybody's PRs.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>That's when you start to look further.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"when-the-report-is-long-use-pr-checks\"><a class=\"anchor\" href=\"#when-the-report-is-long-use-pr-checks\"></a>When the report is long: Use PR checks</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Your job generates a long report at the end, but the Checks section can only accommodate a couple of words.\nYou have been rendering the reports as HTML and attaching them to the Jenkins builds themselves (perhaps with a nice <a href=\"https://palletsprojects.com/p/jinja/\">Jinja2 template</a> and <a href=\"https://plugins.jenkins.io/htmlpublisher/\">the HTML Publisher plugin</a>).\nThe commit statuses your job writes to PRs contain links to the Jenkins builds themselves, so it's only two clicks away from an HTML report&#8201;—&#8201;not bad.</p>\n</div>\n<div class=\"paragraph\">\n<p>To prevent past HTML reports from saturating the disk, you configured the job to only keep the 20 most recent builds.\nThen the team grew and people started complaining that their reports are getting purged before they could even take a look.\nYou now have a <strong>scalability</strong> problem.</p>\n</div>\n<div class=\"paragraph\">\n<p>Let's move those reports away from Jenkins, and what's a better place than <strong>the PRs themselves</strong>?</p>\n</div>\n<div class=\"paragraph\">\n<p>Following <a href=\"https://docs.cloudbees.com/docs/cloudbees-ci/latest/traditional-admin-guide/github-app-auth\">this guide from CloudBees</a>, you created a GitHub App, installed it onto your repo, generated a SSH private key for the app, and uploaded it to Jenkins credentials storage with \"GitHub App\" as the <em>Kind</em>.\n(For the GitHub half of the journey, <a href=\"http://thecodebarbarian.com/building-a-github-app-with-node-js.html\">this tutorial</a> has better screenshots.)\nNow that your Jenkins job is <em>allowed</em> to send PR Checks, how do we tell it <em>what</em> to send?</p>\n</div>\n<div class=\"paragraph\">\n<p>That's when these 3 plugins come into play:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://github.com/jenkinsci/checks-api-plugin\">Checks API Plugin</a>: This enables Jenkins to talk to the Checks API on various git hosting platforms, including GitHub, GitLab, and BitBucket.\nThis is a base plugin that is meant to be extended with other plugins, not directly used by Jenkins jobs, though.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/github-checks-plugin\">GitHub Checks API Plugin</a>: This enables Jenkins to talk to GitHub specifically.\nIt extends the aforementioned <a href=\"https://github.com/jenkinsci/checks-api-plugin\">Checks API Plugin</a>.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/junit-plugin\">JUnit Plugin</a>: This publishes JUnit-style XML test reports to various destinations.\nIt posts to the current build, and&#8201;—&#8201;when the <a href=\"https://github.com/jenkinsci/checks-api-plugin\">Checks API Plugin</a> is available&#8201;—&#8201;publishes to GitHub/GitLab/…&#8203;\nas PR Checks.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"/images/post-images/2023/12/06/Screenshot-of-a-JUnit-report-on-PR-Checks-tab.png\" alt=\"Screenshot of a JUnit report on PR Checks tab\"></span> (<a href=\"https://plugins.jenkins.io/junit/\">Source</a> of screenshot)</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"junit-you-said\"><a class=\"anchor\" href=\"#junit-you-said\"></a>JUnit, you said?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Contrary to what the name implies, JUnit XML reports aren't just for JUnit;\nit has been the <em>de facto</em> standard for reporting test results for various testing frameworks (and even for languages besides Java).\nHere are a few examples:</p>\n</div>\n<div class=\"paragraph\">\n<p>In Python, pytest has <a href=\"https://docs.pytest.org/en/7.1.x/how-to/output.html?highlight=junitxml#creating-junitxml-format-files\">native support</a> for creating JUnit XML format reports:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">pytest --junitxml=path</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In Go, the <code>go-junit-report</code> package can translate go test results to JUnit format:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">go test -v 2>&1 ./... | go-junit-report -set-exit-code > report.xml</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In C&#43;&#43;, Google's testing framework (GoogleTest) can <a href=\"https://google.github.io/googletest/advanced.html#generating-an-xml-report\">emit test results as XML</a>, which conforms to the JUnit format:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-shell\" data-lang=\"shell\">export GTEST_OUTPUT=\"xml:/path/to/junit.xml\"\n# Run your normal test command here.</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The JUnit format is described in this article, <a href=\"https://github.com/testmoapp/junitxml#common-junit-xml-format—&#8203;examples\"><em>Common JUnit XML Format & Examples</em></a>, along with some examples.\nYou can also refer to the first 4 lines of the article <a href=\"https://docs.getxray.app/display/XRAY/Taking+advantage+of+JUnit+XML+reports\"><em>Taking advantage of JUnit XML reports</em></a> from Xray.</p>\n</div>\n<div class=\"paragraph\">\n<p>In summary, you can have the Jenkins job emit results in the JUnit XML schema, so that you can send the results as a PR Check via the <a href=\"https://github.com/jenkinsci/junit-plugin\">JUnit Plugin</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"to-update-the-check-at-each-step\"><a class=\"anchor\" href=\"#to-update-the-check-at-each-step\"></a>To update the check at each step</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The plugin:junit[JUnit plugin] is meant for the conclusions, but you might want to publish messages before it concludes.\nDepending on whether your Jenkins job can be naturally split into different <a href=\"/doc/pipeline/tour/running-multiple-steps/\">build steps</a> and be written in a Jenkins Pipeline, there are different ways to achieve this.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Case 1: If you can split your job into self-contained Steps</strong>, you can update PR Checks by interacting with the plugin:checks-api[Checks API plugin] directly.\nBy \"directly\", I mean you don't need to go through its \"consumer plugins\", such as the plugin:junit[JUnit plugin].\nIn Jenkinsfile syntax:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">publishChecks\n  name: 'my-cool-check',\n  title: 'Integration Test',\n  summary: 'Manifest is built. Deploying to a staging pool now.',\n  status: 'IN_PROGRESS',\n    text: 'Nothing much to see here.',\n    detailsURL: 'https://link.to.your/jenkins/build/',\n    actions: []</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is useful when each action your job takes can be written as a standalone call to executables.\nFor example, I may have a job that builds, tests, and publishes my Rust code by calling <code>cargo build</code>, <code>cargo test</code>, and <code>cargo publish</code> respectively.\nSince each step is a separate shell command, I can easily write them as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">// Under pipeline > stages > stage('...') > steps.\nscript {\n  publishChecks name: 'my-cool-check', status: 'IN_PROGRESS',\n    title: 'Build, Test, and Publish',\n    summary: 'Building...'\n  sh 'cargo build'\n  publishChecks name: 'my-cool-check', status: 'IN_PROGRESS',\n    title: 'Build, Test, and Publish',\n    summary: 'Testing...'\n  sh 'cargo test'\n  publishChecks name: 'my-cool-check', status: 'IN_PROGRESS',\n    title: 'Build, Test, and Publish',\n    summary: 'Publishing...'\n  sh 'cargo publish'\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"to-update-the-check-within-a-step\"><a class=\"anchor\" href=\"#to-update-the-check-within-a-step\"></a>To update the Check within a Step</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><strong>Case 2: If your job is quite monolithic</strong>, it can be awkward to split your self-contained script into multiple, just for the sake of separating them as build steps and inserting <code>publishChecks</code> in-between.\nIn these cases, you'll have to directly interact with the GitHub API without the Jenkins layer.\nIn terms of the fancy plugins, this means you even don't have to use the plugin:checks-api[Checks API plugin].</p>\n</div>\n<div class=\"paragraph\">\n<p>For GitHub Apps, the authorization & authentication process can be quite involved:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Back when you installed your GitHub App to your repo, you granted a set of permissions to your App.\nThis is called <strong>authorization</strong>. Exactly what your App can do to your repo can be retrieved from GitHub via an \"Installation ID\".</p>\n</li>\n<li>\n<p>When your script initializes, it needs to authenticate to GitHub as your App.\nTo do so, the script needs a private key of the App.\nYou can generate a private key from the App's settings page and use it forever.</p>\n</li>\n<li>\n<p>If dealing with the raw GitHub API, the authentication is quite involved.\nFirst, you generate a <a href=\"https://jwt.io/introduction\"><em>JSON Web Token</em> (JWT)</a> with the private key.\nThen, you <a href=\"https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app-installation\">call a GitHub endpoint</a> with this JWT, saying \"I'm this App, and I'm trying to access the repos we agreed upon earlier.\"\nThis endpoint gives you an \"installation access token\" (IAT).\nYour script would use this IAT to call other endpoints, just like how you'd use a PAT when calling endpoints manually as yourself.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Luckily, many languages have libraries that handle the intermediate work for you.\nLet's say your Jenkinsfile runs a Python script via (<code>sh './run.py'</code>).\nWe can use the <a href=\"https://github.com/PyGithub/PyGithub\">PyGitHub</a> library to call GitHub APIs Pythonically.</p>\n</div>\n<div class=\"paragraph\">\n<p>In Python, the built-in <a href=\"https://docs.python.org/3/library/logging.html\">logging</a> library is the standard way to emit messages.\nYour script creates a \"logger\" and attaches different \"handlers\" to it, each defining an output channel of your messages such as standard output, file on disk, or remote service.\nIntuitively, we can write a handler for logging to GitHub Checks.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the help of ChatGPT, I implemented <a href=\"https://gist.github.com/tslmy/84f34a25babe045eb302ec72f2bf39eb\">this handler</a>.\nYou can see that the handler requires quite some parameters to initialize.\nWhere do you get them?</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>For locating the PR and the commit, the plugin:github-pullrequest[GitHub Integration plugin] can help.\nIt can trigger Jenkins jobs upon PR events, injecting <a href=\"https://github.com/KostyaSha/github-integration-plugin/blob/master/docs/Configuration.adoc#available-environment-variables\">these environment variables</a> to each Build.\nWe'll use two: <code>GITHUB_PR_HEAD_SHA</code> and <code>GITHUB_REPO_SSH_URL</code>.</p>\n</li>\n<li>\n<p>For referencing from the PR Check to the Jenkins Build, we'll also need an environment variable set by vanilla Jenkins: <code>BUILD_URL</code>.\nOn <a href=\"https://wiki.jenkins.io/display/JENKINS/Building+a+software+project#Buildingasoftwareproject-belowJenkinsSetEnvironmentVariables\">this page</a>, you can find a list of all Jenkins-set variables.</p>\n</li>\n<li>\n<p>For authentication, we are on our own.\nWe can upload the App's private key to Jenkins credentials storage and wrap the <code>sh './run.py'</code> step with the closure <code>sshUserPrivateKey</code>.\nFor the App ID and the Installation ID, since they aren't necessarily secrets, we can afford to spell them out with an <code>environment</code> directive.\nCombined, your Jenkinsfile might look like this:</p>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\nenvironment {\n  GITHUB_APP_ID = '123'\n  GITHUB_APP_INSTALLATION_ID = '456'\n}\nstages {\n  stage('...') {\n    steps {\n      script {\n        sshUserPrivateKey (\n          credentialsId: \"...\", // ID from the Jenkins credentials storage.\n          keyFileVariable: 'GITHUB_APP_PRIVATE_KEY_PATH') {\n            sh './run.py'</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Now, in your Python script, you can read the environment variables during initialization:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-python\" data-lang=\"python\">import logging\nfrom GitHubCheckHandler import GitHubCheckHandler\n\nlogger = logging.getLogger('...')\n\nhandler = GitHubCheckHandler(\n  private_key_path=str(os.getenv(\"GITHUB_APP_PRIVATE_KEY_PATH\")),\n  installation_id=int(str(os.getenv(\"GITHUB_APP_INSTALLATION_ID\"))),\n  github_app_id=int(str(os.getenv(\"GITHUB_APP_ID\"))),\n  owner_repo=str(os.getenv(\"GITHUB_REPO_SSH_URL\"))\n    .removeprefix(\"git@github.com:\")\n    .removesuffix(\".git\"),\n  commit_sha=str(os.getenv(\"GITHUB_PR_HEAD_SHA\")),\n  details_url=str(os.getenv(\"BUILD_URL\")),\n)\n\nlogger.addHandler(handler)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then, you should be able to see Python logs directly in the PR Checks sections.\nNote that the yellow light besides your check will keep spinning as you send messages.\nTo tell GitHub that this check has finished, you should call the <code>handler.conclude(...)</code> method.\nTherefore, you should keep the handler object exposed to your main function.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"summary\"><a class=\"anchor\" href=\"#summary\"></a>Summary</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In this guide, we've explored how to automate and enhance PR quality assurance by tightening the integration between Jenkins and GitHub, specifically by emitting richer logs back to the PRs in a more timely manner.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the missing link of the feedback loop filled, we boost developers' productivity.\nBy freeing them from manually checking the results and attaching screenshots, we save developers' precious time and brain capacity, which can be devoted to more creative work.</p>\n</div>\n<div class=\"paragraph\">\n<p>In summary, automation not only boosts efficiency but also elevates the overall quality of your software development process.\nSo, don't hesitate!\nStart automating your PR quality assurance today and experience the benefits of a more streamlined and productive workflow.</p>\n</div>\n<div class=\"paragraph\">\n<p>Thank you for following along and happy coding!</p>\n</div>\n</div>\n</div>"
}